# Project Write Up
### Task 02

## Selected Algorithm Analysis
- The algorithm implemented in this solution is Dijkstra's Algorithm. The reason I chose to implement Dijkstra's algorithm, as opposed to another algorithm, is because the data set used in this project is optimal for Dijkstra's. The imported data set which the algorithm runs on is a single source weighted directed graph. The graph is also acyclic and there are no negatively weghted edges. The two main strengths of Dijkstra's algorithm are the algorithms simplicity for implementation and it's greedy approach. Firstly, the algorithm is quite simple to implement consisting of a for-loop and a while-loop which contains a nested for-loop and nested conditional. Secondly, the algorithm takes a greedy approach to its analysis which can greatly reduce space-complexity especially on a large scale data-set. The main drawback on Dijkstra's algorithm is that this data set is a complete graph, so the time complexity of the algorithm is quadratic O(n^2). (Cormen, Introduction to Algorithsm p.620-624)

## Alternative Algorithms
- In addition to Dijkstra's algorithm there are several other algorithms which could be implemented to solve this project namely: The Bellman-Ford Algorithm as well as The Floyd-Warshall Algorithm. The Bellman-Ford Algorithm is quite similar to Dijkstra's, but unlike Dijkstra's, Bellman-Ford can still operate if negatively weighted edges are present. The algorithm implements an extra check sequence to verify if there is path from the start vertex to the end vertex which includes no negatively weighted edges. In this scenario there would be no benifit in using the Bellman-Ford algorithm over Dijkstra's as we can say for certain there are no negatively weighted edges present in the data set (Cormen, Introduction to Algorithsm p.612-615). In regards to Floyd-Warshall Algorithm it also can handle negatively weighted edges, but it cannot handle negatively weighted cycles. However, the algorithm can detect if negatively weighted cycles are present. The main drawback of the Floyd-Warshall Algorithm is it's quadratic space complexity O(n^2) and it's exponential time complexity O(n^3) (Cormen, Introduction to Algorithsm p.655-660)

## Selected Data-Structure Analysis
- The Data strucutre implemented in this solution is a hash map which uses closed addressing with chaining for collision resolution. The data structure takes advantage of the fact that every package object has a unique package ID and uses this integer as input for the hash function. The hash funciton which is ID(mod 16) will produce an integer within the range of 0-15 which has a 1:1 correspondance to the index size of the hash map. The main benifit of the hash data strucutre is it's constant time complexity O(1) for object searches when independent uniform hashing is present.

## Alternative Data-Structures
- The hash map data strucutre is not the only solution to this project two other possible data strucutres could be: a Linked List or a Heap. Firstly, the Linked List could suffice to solve the project but it would not be optimal especially with a large-scale data set. The main drawback to using a Linked List would the linear time complexity O(n) for search operations in comparisson to the constant time O(1) offered by the Hash Map. Secondly, the heap data strucutre, particularly a minimum heap, would also work for solving this project. The min-heap is preferrable to the linked list and also works in conjuction with Dijkstra's algorithm. However, for the particular operation of this project the min-heaps logarithmic time complexity O(log n) is better than the linear O(n) offered by the Linked List but still falls behind the constant time O(1) offered by the hash map for search operations. In the event that the data set was substantially larger, and chaining became more of an occurance within the hash map, then it would be concievable the the min-heap would perform better under certain conditions.

## Possible Modifications
- Looking back on the project now there are several things I would have done differently. Firstly, I would have opted out of using a doubly linked list in favor of a traditional linked list in order to save on memory usage. Secondly, I would implement Dijkstra's algorithm to run on the entire data in one operation as opposed to three smaller operations, on for earch truck. Finally, I would adapt the project to be able to scale better by automating the package loading process onto truck objects.